# pizzashop

**Мови:**  
[Ukrainian](README.uk.md) | [English](README.md)

### [Pizzashop Live page](https://zerossik.github.io/pizzashop/)

<sub>Адаптивний лендинг для невеликої піцерії. Сайт дозволяє користувачам обрати піцу, вибрати її розмір та додати додаткові інгредієнти, після чого можна перейти до оформлення замовлення.
Сайт створений за допомогою таких технологій: HTML, CSS (SASS) та JavaScript (ES6).
Для карток товарів і кошика я використовував патерни MVVM (Model-View-ViewModel) та Observer.
Для відстеження змін даних я створив власну реалізацію хука useState на основі ProxyObject.
Слайдер (для мобільної та планшетної версії сайту) реалізовано за допомогою Swiper.js (Web Components).</sub>

---

## Hook: `useState`

Коротко: `useState` — проста реалізація реактивного стану на основі `Proxy`. Дозволяє відстежувати зміни в об’єкті або масиві та викликати callback під час мутацій.

- **Файл:** `js/hooks/useState.js`
- **Призначення:** створити проксі-об’єкт, який викликає `onChange` під час присвоєнь значень і при виклику мутабельних методів масивів.

Параметри:

- `initState` (any) — початковий стан. Якщо передано не об’єктне значення (примітив), воно буде загорнуте в `{ value: initState }`.
- `onChange` (function) — необов’язковий callback, що викликається під час змін.
- `onChange` приймає параметри `target, prop, value`

Повертає:

- `Proxy` — проксі-версію переданого стану. Для вкладених об’єктів застосовується рекурсивне обгортання через `useState`.

Як це працює (коротко):

- Використовується `WeakMap` (`proxyMap`) для зберігання відповідності вихідний об’єкт (кеш) → проксі, щоб не проксувати один і той самий об’єкт кілька разів.
- При `set` порівнюється попереднє значення та нове (`prevState === value`) — якщо вони однакові, callback не викликається.
- Для масивів перехоплюються стандартні мутуючі методи (`push`, `pop`, `splice` та ін.), і при їх виклику викликається `onChange` з аргументами.

Приклади використання:

```javascript
import { useState } from "./js/hooks/useState.js";

// Об'єкт
const state = useState(
  { count: 0, user: { name: "Anna" } },
  (target, prop, value) => {
    console.log("changed", prop, value);
  }
);
state.count = 1; // -> onChange(target, 'count', 1)
state.user.name = "Ivan"; // вкладений об'єкт також проксирується автоматично

// Масив
const arr = useState([1, 2, 3], (target, prop, args) => {
  console.log("array", prop, args);
});
arr.push(4); // -> onChange(target, 'push', [4])
```

- `useState` повертає той самий проксі при повторному виклику з тим самим об’єктом (через `WeakMap`) — це запобігає дублюванню проксування.
- Callback викликається лише при реальній зміні значення (за посиланням/значенням).
- Не перехоплюються немутуючі операції та доступи — лише `set` і мутуючі методи масивів.
- Під час використання на великих структурах даних враховуйте витрати на проксування вкладених об'єктів.

---

## Функціонал кошика: `CartModel`, `CartViewModel`, `CartView`

### CartModel (`js/Cart/CartModel.js`)

**Призначення:** управління даними кошика та збереженням у LocalStorage.

**Основні методи:**

- `addItem(item)` — додає товар до кошика. Якщо товар вже існує, оновлює його кількість
- `updateItem(itemData)` — оновлює дані товара (кількість, розмір, тощо)
- `removeItem(id)` — видаляє товар з кошика
- `clearCart()` — очищає весь кошик
- `getItemPriceById(id)` — обчислює вартість товара з урахуванням розміру та додаткових інгредієнтів
- `totalPrice` (getter) — обчислює загальну вартість всіх товарів у кошику
- `items` (getter) — повертає масив всіх товарів у кошику

**Валідація:** клас перевіряє, що кожен товар містить обов'язкові властивості (`id`, `title`, `image`, `ingredientPrices`, `optionPrices`, `pizzaSize`, `quantity`, `addedIngredients`).

**Збереження:** усі зміни автоматично синхронізуються з LocalStorage через Observable паттерн.

### CartViewModel (`js/Cart/CartViewModel.js`)

**Призначення:** прошарок між UI та моделлю, який керує станом та сповіщеннями про зміни.

**Основні методи:**

- `addItem(item)` — делегує додавання товара до CartModel
- `removeItem(id)` — видаляє товар з кошика
- `updateItem(itemData)` — оновлює товар у кошику
- `clearCart()` — очищає кошик
- `openCart()` — сповіщує підписники про відкриття модального вікна кошика
- `getItemPriceById(id)` — отримує вартість товара з моделі
- `items` (getter) — повертає список товарів з моделі
- `totalPrice` (getter) — повертає загальну вартість кошика

**Реактивність:** розширює `Observable`, тому будь-яка зміна в CartModel автоматично сповіщує UI.

### CartView (`js/Cart/CartView.js`)

**Призначення:** відображення UI кошика та обробка користувацьких дій.

**Основні функції:**

- `openCart()` — відкриває модальне вікно з вмістом кошика
- Динамічне рендерування списку товарів у кошику
- Оновлення ціни при зміні кількості товара
- Видалення товара при кліку на кнопку видалення
- Управління лічильником (selector кількості) для кожного товара
- Відключення кнопки оформлення замовлення, якщо кошик пуста

**Внутрішня структура:**

- `#itemsInCart` (Map) — зберігає посилання на DOM елементи та лічильник для кожного товара
- `#createCartLayout()` — створює розмітку кошика
- `#render()` — перераховує кошик при змінах (додавання, видалення, оновлення товарів)
- `#attachEvents()` — приєднує обробники подій (відкриття кошика, видалення товара)

**Інтеграція:** CartView підписується на зміни в CartViewModel та автоматично оновлює вигляд при будь-яких змінах у даних.

---

## Counter (`js/counter.js`)

**Призначення:** управління числовим лічильником кількості товарів зі можливістю збільшення та зменшення значення.

**Конструктор:**

```javascript
new Counter(counterElement);
```

- `counterElement` (HTMLElement) — HTML елемент лічильника, який повинен містити:
  - `data-min_value` — мінімальне значення (за замовчуванням 1)
  - `data-max_value` — максимальне значення (за замовчуванням 99)
  - `data-init_value` — початкове значення (за замовчуванням дорівнює мінімальному)
  - Дочірній елемент `<input name="counter-value">` для відображення поточного значення

**Основні методи:**

- `increment()` — збільшує значення на 1 (не може перевищити максимум)
- `decrement()` — зменшує значення на 1 (не може бути менше мінімуму)
- `updateValue(value)` — встановлює нове значення з валідацією
  - Генерує помилку, якщо значення менше мінімуму або більше максимуму
  - Генерує помилку, якщо значення не число
- `render()` — оновлює відображення значення у input елементі
- `destroy()` — видаляє всі обробники подій та очищає ресурси
- `value` (getter) — повертає поточне значення

**Обробка подій:**

- Клікі на `.counter__increment` — викликають `increment()`
- Клікі на `.counter__decrement` — викликають `decrement()`
- Зміни вмісту input — викликають `handlerChange()`, який валідує та встановлює нове значення

**Реактивність:**

- Розширює `Observable`, тому при зміні значення автоматично сповіщує всіх підписників
- Використовує `useState` для відстеження змін значення
- Змінених значення оновлюються за допомогою `requestAnimationFrame` для оптимальної продуктивності

**Приклад використання:**

```html
<div class="counter" data-min_value="1" data-max_value="10" data-init_value="1">
  <button class="counter__decrement">-</button>
  <input type="number" name="counter-value" />
  <button class="counter__increment">+</button>
</div>
```

```javascript
const counterElement = document.querySelector(".counter");
const counter = new Counter(counterElement);

// Підписка на зміни
counter.subscribe((value) => {
  console.log("Нова кількість:", value);
});

// Встановити нове значення
counter.updateValue(5);
```

---

## Modal (`js/modal.js`)

**Призначення:** відображення модальних вікон з налаштовуваним вмістом, заголовками та механізмами закриття.

**Конструктор:**

```javascript
new Modal(title);
```

- `title` (string) — заголовок, що відображається в шапці модалки (обов'язковий)
- Генерує `TypeError`, якщо title не є рядком
- Вимагає наявності елемента `#modal-root` у DOM для рендерування модалки

**Основні методи:**

- `show(htmlContent)` — відкриває модалку з вказаним HTML вмістом
  - `htmlContent` (HTMLElement, опціонально) — вміст для відображення всередині модалки
  - Приєднує обробники подій при відкритті модалки
  - Повертає `this` для ланцюгування методів
- `close()` — закриває модалку
  - Видаляє вміст та відключає обробники подій
  - Викликається автоматично після анімації закриття
- `setContent(newContent, isClearModal)` — оновлює вміст модалки після її відкриття
  - `newContent` (HTMLElement) — новий вміст для відображення
  - Генерує `TypeError`, якщо вміст не є HTMLElement

**Властивості та сеттери:**

- `title` (setter) — динамічно оновлює заголовок модалки
  - Оновлює DOM елемент та внутрішній стан
  - Генерує `TypeError`, якщо title не є рядком
- `modal` — кореневий DOM елемент модалки
- `modalRoot` — DOM вузол, де рендеруються модалки (мусить мати id `modal-root`)
- `modalTitle` — елемент заголовка всередині модалки

**Обробка подій:**

- Клікі на кнопку `.modal__close` — закривають модалку
- Клікі на `.modal__backdrop` (накладку) — закривають модалку
- Натискання клавіші `Escape` — закривають модалку
- Усі обробники правильно очищаються при закритті модалки

**Внутрішня структура:**

- `#state` (реактивний) — відслідковує стан `isOpen` та `title` за допомогою `useState`
- `#modalInner` — контейнер для вмісту модалки
- `#createModal()` — створює HTML структуру модалки з шапкою, кнопкою закриття та областю вмісту
- `#render()` — керує відображенням/приховуванням модалки з анімаціями та маніпуляцією DOM
- `#attachEvents()` — приєднує всі обробники подій
- `#destroyEvent()` — видаляє всі обробники подій

**Реактивність та анімація:**

- Використовує `useState` для відслідковування змін стану
- Вставлення/видалення модалки обробляється реактивно на основі стану `isOpen`
- Анімація відкриття: модалка додається в DOM, та класу `.modal__show` застосовується через `requestAnimationFrame`
- Анімація закриття: клас `.modal__show` видаляється, потім модалка видаляється з DOM після затримки 200мс
- Overflow тіла сторінки приховується при відкритій модалці, відновлюється при закритті

**Приклад використання:**

```html
<div id="modal-root"></div>
```

```javascript
const modal = new Modal("Кошик");

// Відкрити модалку з вмістом
const content = document.createElement("div");
content.innerHTML = "<p>Товари вашого кошика тут</p>";
modal.show(content);

// Оновити заголовок
modal.title = "Мій кошик";

// Оновити вміст після відкриття
const newContent = document.createElement("div");
newContent.innerHTML = "<p>Оновлений кошик</p>";
modal.setContent(newContent);

// Закрити модалку
modal.close();
```

---

## Notify (`js/notify.js`)

**Призначення:** відображення коротких тимчасових повідомлень користувачу з автоматичним закриттям та можливістю ручного закриття.

**Вимоги:**

- У DOM повинен бути кореневий елемент `.notify` з дочірнім `.notify__content` для виводу тексту.
- За бажанням можна додати кнопку закриття з класом `.notify__close` для ручного приховування.

**Основні методи:**

- `show(content)` — показує повідомлення із переданим рядком `content`.
  - Генерує `TypeError`, якщо `content` не є рядком.
  - Очищає будь-який наявний таймер автозакриття перед показом нового повідомлення.
  - Встановлює внутрішній вміст і відкриває UI повідомлення.
- `close()` — негайно ховає повідомлення.

**Поведінка та реалізація:**

- Використовує хук `useState` для відстеження `isOpen` і виклику реактивного `render()` при змінах.
- Коли повідомлення відкрите, `render()` встановлює текст у `.notify__content`, додає клас `.notify--show` та планує автоматичне закриття через `#closeWithDelay()` (3000мс).
- Якщо приходить нове повідомлення під час активного таймера, попередній таймер очищається, і вміст оновлюється негайно.
- Клік по `.notify__close` викликає `close()`.

**Приклад використання:**

```html
<div class="notify">
  <div class="notify__content"></div>
  <button class="notify__close">×</button>
</div>
```

```javascript
import Notify from "./js/notify.js";

Notify.show("Товар додано в кошик");

// Закрити вручну
Notify.close();
```
