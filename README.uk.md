# pizzashop

**Мови:**  
[Ukrainian](README.uk.md) | [English](README.md)

### [Pizzashop Live page](https://zerossik.github.io/pizzashop/)

<sub>Адаптивний лендинг для невеликої піцерії. Сайт дозволяє користувачам обрати піцу, вибрати її розмір та додати додаткові інгредієнти, після чого можна перейти до оформлення замовлення.
Сайт створений за допомогою таких технологій: HTML, CSS (SASS) та JavaScript (ES6).
Для карток товарів і кошика я використовував патерни MVVM (Model-View-ViewModel) та Observer.
Для відстеження змін даних я створив власну реалізацію хука useState на основі ProxyObject.
Слайдер (для мобільної та планшетної версії сайту) реалізовано за допомогою Swiper.js (Web Components).</sub>

---

## Hook: `useState`

Коротко: `useState` — проста реалізація реактивного стану на основі `Proxy`. Дозволяє відстежувати зміни в об’єкті або масиві та викликати callback під час мутацій.

- **Файл:** `js/hooks/useState.js`
- **Призначення:** створити проксі-об’єкт, який викликає `onChange` під час присвоєнь значень і при виклику мутабельних методів масивів.

Параметри:

- `initState` (any) — початковий стан. Якщо передано не об’єктне значення (примітив), воно буде загорнуте в `{ value: initState }`.
- `onChange` (function) — необов’язковий callback, що викликається під час змін.
- `onChange` приймає параметри `target, prop, value`

Повертає:

- `Proxy` — проксі-версію переданого стану. Для вкладених об’єктів застосовується рекурсивне обгортання через `useState`.

Як це працює (коротко):

- Використовується `WeakMap` (`proxyMap`) для зберігання відповідності вихідний об’єкт (кеш) → проксі, щоб не проксувати один і той самий об’єкт кілька разів.
- При `set` порівнюється попереднє значення та нове (`prevState === value`) — якщо вони однакові, callback не викликається.
- Для масивів перехоплюються стандартні мутуючі методи (`push`, `pop`, `splice` та ін.), і при їх виклику викликається `onChange` з аргументами.

Приклади використання:

```javascript
import { useState } from "./js/hooks/useState.js";

// Об'єкт
const state = useState(
  { count: 0, user: { name: "Anna" } },
  (target, prop, value) => {
    console.log("changed", prop, value);
  }
);
state.count = 1; // -> onChange(target, 'count', 1)
state.user.name = "Ivan"; // вкладений об'єкт також проксирується автоматично

// Масив
const arr = useState([1, 2, 3], (target, prop, args) => {
  console.log("array", prop, args);
});
arr.push(4); // -> onChange(target, 'push', [4])
```

- `useState` повертає той самий проксі при повторному виклику з тим самим об’єктом (через `WeakMap`) — це запобігає дублюванню проксування.
- Callback викликається лише при реальній зміні значення (за посиланням/значенням).
- Не перехоплюються немутуючі операції та доступи — лише `set` і мутуючі методи масивів.
- Під час використання на великих структурах даних враховуйте витрати на проксування вкладених об’єктів.

---
