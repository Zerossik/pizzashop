# pizzashop

**Мови:**  
[Ukrainian](README.uk.md) | [English](README.md)

### [Pizzashop Live page](https://zerossik.github.io/pizzashop/)

<sub>Адаптивний лендинг для невеликої піцерії. Сайт дозволяє користувачам обрати піцу, вибрати її розмір та додати додаткові інгредієнти, після чого можна перейти до оформлення замовлення.
Сайт створений за допомогою таких технологій: HTML, CSS (SASS) та JavaScript (ES6).
Для карток товарів і кошика я використовував патерни MVVM (Model-View-ViewModel) та Observer.
Для відстеження змін даних я створив власну реалізацію хука useState на основі ProxyObject.
Слайдер (для мобільної та планшетної версії сайту) реалізовано за допомогою Swiper.js (Web Components).</sub>

---

## Hook: `useState`

Коротко: `useState` — проста реалізація реактивного стану на основі `Proxy`. Дозволяє відстежувати зміни в об’єкті або масиві та викликати callback під час мутацій.

- **Файл:** `js/hooks/useState.js`
- **Призначення:** створити проксі-об’єкт, який викликає `onChange` під час присвоєнь значень і при виклику мутабельних методів масивів.

Параметри:

- `initState` (any) — початковий стан. Якщо передано не об’єктне значення (примітив), воно буде загорнуте в `{ value: initState }`.
- `onChange` (function) — необов’язковий callback, що викликається під час змін.
- `onChange` приймає параметри `target, prop, value`

Повертає:

- `Proxy` — проксі-версію переданого стану. Для вкладених об’єктів застосовується рекурсивне обгортання через `useState`.

Як це працює (коротко):

- Використовується `WeakMap` (`proxyMap`) для зберігання відповідності вихідний об’єкт (кеш) → проксі, щоб не проксувати один і той самий об’єкт кілька разів.
- При `set` порівнюється попереднє значення та нове (`prevState === value`) — якщо вони однакові, callback не викликається.
- Для масивів перехоплюються стандартні мутуючі методи (`push`, `pop`, `splice` та ін.), і при їх виклику викликається `onChange` з аргументами.

Приклади використання:

```javascript
import { useState } from "./js/hooks/useState.js";

// Об'єкт
const state = useState(
  { count: 0, user: { name: "Anna" } },
  (target, prop, value) => {
    console.log("changed", prop, value);
  }
);
state.count = 1; // -> onChange(target, 'count', 1)
state.user.name = "Ivan"; // вкладений об'єкт також проксирується автоматично

// Масив
const arr = useState([1, 2, 3], (target, prop, args) => {
  console.log("array", prop, args);
});
arr.push(4); // -> onChange(target, 'push', [4])
```

- `useState` повертає той самий проксі при повторному виклику з тим самим об’єктом (через `WeakMap`) — це запобігає дублюванню проксування.
- Callback викликається лише при реальній зміні значення (за посиланням/значенням).
- Не перехоплюються немутуючі операції та доступи — лише `set` і мутуючі методи масивів.
- Під час використання на великих структурах даних враховуйте витрати на проксування вкладених об'єктів.

---

## Функціонал кошика: `CartModel`, `CartViewModel`, `CartView`

### CartModel (`js/Cart/CartModel.js`)

**Призначення:** управління даними кошика та збереженням у LocalStorage.

**Основні методи:**

- `addItem(item)` — додає товар до кошика. Якщо товар вже існує, оновлює його кількість
- `updateItem(itemData)` — оновлює дані товара (кількість, розмір, тощо)
- `removeItem(id)` — видаляє товар з кошика
- `clearCart()` — очищає весь кошик
- `getItemPriceById(id)` — обчислює вартість товара з урахуванням розміру та додаткових інгредієнтів
- `totalPrice` (getter) — обчислює загальну вартість всіх товарів у кошику
- `items` (getter) — повертає масив всіх товарів у кошику

**Валідація:** клас перевіряє, що кожен товар містить обов'язкові властивості (`id`, `title`, `image`, `ingredientPrices`, `optionPrices`, `pizzaSize`, `quantity`, `addedIngredients`).

**Збереження:** усі зміни автоматично синхронізуються з LocalStorage через Observable паттерн.

### CartViewModel (`js/Cart/CartViewModel.js`)

**Призначення:** прошарок між UI та моделлю, який керує станом та сповіщеннями про зміни.

**Основні методи:**

- `addItem(item)` — делегує додавання товара до CartModel
- `removeItem(id)` — видаляє товар з кошика
- `updateItem(itemData)` — оновлює товар у кошику
- `clearCart()` — очищає кошик
- `openCart()` — сповіщує підписники про відкриття модального вікна кошика
- `getItemPriceById(id)` — отримує вартість товара з моделі
- `items` (getter) — повертає список товарів з моделі
- `totalPrice` (getter) — повертає загальну вартість кошика

**Реактивність:** розширює `Observable`, тому будь-яка зміна в CartModel автоматично сповіщує UI.

### CartView (`js/Cart/CartView.js`)

**Призначення:** відображення UI кошика та обробка користувацьких дій.

**Основні функції:**

- `openCart()` — відкриває модальне вікно з вмістом кошика
- Динамічне рендерування списку товарів у кошику
- Оновлення ціни при зміні кількості товара
- Видалення товара при кліку на кнопку видалення
- Управління лічильником (selector кількості) для кожного товара
- Відключення кнопки оформлення замовлення, якщо кошик пуста

**Внутрішня структура:**

- `#itemsInCart` (Map) — зберігає посилання на DOM елементи та лічильник для кожного товара
- `#createCartLayout()` — створює розмітку кошика
- `#render()` — перераховує кошик при змінах (додавання, видалення, оновлення товарів)
- `#attachEvents()` — приєднує обробники подій (відкриття кошика, видалення товара)

**Інтеграція:** CartView підписується на зміни в CartViewModel та автоматично оновлює вигляд при будь-яких змінах у даних.

---

## Counter (`js/counter.js`)

**Призначення:** управління числовим лічильником кількості товарів зі можливістю збільшення та зменшення значення.

**Конструктор:**

```javascript
new Counter(counterElement);
```

- `counterElement` (HTMLElement) — HTML елемент лічильника, який повинен містити:
  - `data-min_value` — мінімальне значення (за замовчуванням 1)
  - `data-max_value` — максимальне значення (за замовчуванням 99)
  - `data-init_value` — початкове значення (за замовчуванням дорівнює мінімальному)
  - Дочірній елемент `<input name="counter-value">` для відображення поточного значення

**Основні методи:**

- `increment()` — збільшує значення на 1 (не може перевищити максимум)
- `decrement()` — зменшує значення на 1 (не може бути менше мінімуму)
- `updateValue(value)` — встановлює нове значення з валідацією
  - Генерує помилку, якщо значення менше мінімуму або більше максимуму
  - Генерує помилку, якщо значення не число
- `render()` — оновлює відображення значення у input елементі
- `destroy()` — видаляє всі обробники подій та очищає ресурси
- `value` (getter) — повертає поточне значення

**Обробка подій:**

- Клікі на `.counter__increment` — викликають `increment()`
- Клікі на `.counter__decrement` — викликають `decrement()`
- Зміни вмісту input — викликають `handlerChange()`, який валідує та встановлює нове значення

**Реактивність:**

- Розширює `Observable`, тому при зміні значення автоматично сповіщує всіх підписників
- Використовує `useState` для відстеження змін значення
- Змінених значення оновлюються за допомогою `requestAnimationFrame` для оптимальної продуктивності

**Приклад використання:**

```html
<div class="counter" data-min_value="1" data-max_value="10" data-init_value="1">
  <button class="counter__decrement">-</button>
  <input type="number" name="counter-value" />
  <button class="counter__increment">+</button>
</div>
```

```javascript
const counterElement = document.querySelector(".counter");
const counter = new Counter(counterElement);

// Підписка на зміни
counter.subscribe((value) => {
  console.log("Нова кількість:", value);
});

// Встановити нове значення
counter.updateValue(5);
```

---
